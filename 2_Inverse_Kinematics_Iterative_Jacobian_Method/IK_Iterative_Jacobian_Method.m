(* ::Package:: *)

(* ::Input:: *)
(*(*Author:Midhun Varghese*)
(*GitHub:https://github.com/midhun-varghese*)
(**)
(*This program is used to obtain the Inverse Kinematics of a given serial manipulator using the Iterative Jacobian Method. This program maps the toolspace or the workspace of a manipulator with its joint space. For this example, a 3-R (3 Revolute Joint) Robot is taken as reference.   *)
(**)
(*Note*: Before running this program, run the FK_Transformation_Jacobian Program so that the required data is present in Mathematica *)
(**)
(*Define function for X-Y-Z fixed angle rotation (roll-pitch-yaw)*)
(*   *)*)
(**)
(*RXYZ[roll_,pitch_,yaw_] := {{Cos[yaw]*Cos[pitch],Cos[yaw]*Sin[pitch]*Sin[roll]-Sin[yaw]*Cos[roll],Cos[yaw]*Sin[pitch]*Cos[roll]+Sin[yaw]*Sin[roll]},*)
(*                 {Sin[yaw]*Cos[pitch],Sin[yaw]*Sin[pitch]*Sin[roll]+Cos[yaw]*Cos[roll],Sin[yaw]*Sin[pitch]*Cos[roll]-Cos[yaw]*Sin[roll]},*)
(*		         {-Sin[pitch],Cos[pitch]*Sin[roll],Cos[pitch]*Cos[roll]}} ;*)
(**)
(*(*Set the current joint angles and desired change in Cartesian pose  *)*)
(*(*In this section deifne the initial pose or the orientation in the intial state*)*)
(*qinit = {{0},{-Pi/4},{0},{0},{-Pi/4},{0}}   //N ;*)
(*q = qinit ;*)
(*Print["initial q = ",qinit];*)
(**)
(*(*  Set desired change in Cartesian position and orientation (pose)*)
(*  [In this case a 1cm transaltion and a 1degree rotation about all the axes are given as the required changes or the desired motion/movement]  *)*)
(*dpdes = {{0.01},{0.01},{0.01}} ;*)
(*Print["desired dp = ",MatrixForm[dpdes]] ;*)
(*onedeg = Pi/180 //N ;*)
(*dRdes = RXYZ[onedeg,onedeg,onedeg] ;*)
(*Print["desired dR = ",MatrixForm[dRdes]] ;*)
(**)
(*(*This section finds the current Cartesian Position and Jacobian  *)*)
(*(*  Substitute any CONSTANT D-H parameters and tool vector pNT in p0T, R0T, and J0  *)*)
(*p0T = p0T /.{Subscript[a, 2]->0.43181,Subscript[a, 3]->0.02032,Subscript[d, 3]->0.12446,Subscript[d, 4]->0.43181,Subscript[z, T]->0.2} ;*)
(*R0T = R0T /.{Subscript[a, 2]->0.43181,Subscript[a, 3]->0.02032,Subscript[d, 3]->0.12446,Subscript[d, 4]->0.43181,Subscript[z, T]->0.2} ;*)
(*J0 = J0 /.{Subscript[a, 2]->0.43181,Subscript[a, 3]->0.02032,Subscript[d, 3]->0.12446,Subscript[d, 4]->0.43181,Subscript[z, T]->0.2} ;*)
(**)
(*(*  Initialize initial values of joint variables (d[i] or \[Theta][i]) in p0Tcurrent, R0Tcurrent, and J0current*)
(*NOTE:  You have to change these next three lines if your variables include d[i]'s  *)*)
(*p0Tcurrent = p0T /.{\[Theta][1]->q[[1,1]],\[Theta][2]->q[[2,1]],\[Theta][3]->q[[3,1]],\[Theta][4]->q[[4,1]],\[Theta][5]->q[[5,1]],\[Theta][6]->q[[6,1]]} ;*)
(*R0Tcurrent = R0T /.{\[Theta][1]->q[[1,1]],\[Theta][2]->q[[2,1]],\[Theta][3]->q[[3,1]],\[Theta][4]->q[[4,1]],\[Theta][5]->q[[5,1]],\[Theta][6]->q[[6,1]]} ;*)
(*J0current = J0/.{\[Theta][1]->q[[1,1]],\[Theta][2]->q[[2,1]],\[Theta][3]->q[[3,1]],\[Theta][4]->q[[4,1]],\[Theta][5]->q[[5,1]],\[Theta][6]->q[[6,1]]} ;*)
(**)
(*Print["initial p0T = ",MatrixForm[p0Tcurrent]] ;*)
(*Print["initial R0T = ",MatrixForm[R0Tcurrent]] ;*)
(*Print["initial J0 = ",MatrixForm[J0current]] ;*)
(**)
(*rankJ = MatrixRank[J0current] ;*)
(*Print["rankJ = ",rankJ] ;*)
(**)
(*(*  Use the pseudoinverse to calculate the Jacobian in case it is singular;*)
(*if DOF=6, then the pseudoinverse of J is the same as the inverse of J *)*)
(*JJT = J0current.Transpose[J0current] ;*)
(*Manipulability = Sqrt[Det[JJT]] ;*)
(*Print["Manipulability = ",Manipulability] ;*)
(*Jpseudoinverse=PseudoInverse[J0current] ;*)
(*Jpseudoinverse = Chop[Jpseudoinverse] ;*)
(*Print["initial Jpseudoinverse = ",MatrixForm[Jpseudoinverse]] ;*)
(**)
(*(*  Find desired Cartesian Position and Orientation  *)*)
(*p0Tdes = p0Tcurrent + dpdes ;*)
(*R0Tdes = dRdes.R0Tcurrent ;*)
(*Print["p0Tdes = ",MatrixForm[p0Tdes]] ;*)
(*Print["R0Tdes = ",MatrixForm[R0Tdes]] ;*)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*(*This section initializes the vectors and iteration number*)*)
(*dpsi = Table[0,{3},{1}] ;*)
(*dx = Table[0,{6},{1}] ;*)
(*iteration = 0 ;*)
(**)
(*(* -------------- START ITERATION -------------------------  *)*)
(**)
(*While[iteration<3,*)
(*{*)
(*(*  increment iteration number  *)*)
(*iteration = iteration + 1 ;*)
(*Print["=====> ITERATION # ",iteration," <====="];*)
(**)
(*(*  STEP 1:  Find current Cartesian Position*)
(*NOTE:  You have to change these next two lines if your variables include d[i]'s  *)*)
(*p0Tcurrent = p0T /.{\[Theta][1]->q[[1,1]],\[Theta][2]->q[[2,1]],\[Theta][3]->q[[3,1]],\[Theta][4]->q[[4,1]],\[Theta][5]->q[[5,1]],\[Theta][6]->q[[6,1]]} ;*)
(*R0Tcurrent = R0T /.{\[Theta][1]->q[[1,1]],\[Theta][2]->q[[2,1]],\[Theta][3]->q[[3,1]],\[Theta][4]->q[[4,1]],\[Theta][5]->q[[5,1]],\[Theta][6]->q[[6,1]]} ;*)
(*Print["p0Tcurrent = ",MatrixForm[p0Tcurrent]] ;*)
(*Print["R0Tcurrent = ",MatrixForm[R0Tcurrent]] ;*)
(**)
(*(*  STEP 2:  Find difference between actual and desired Cartesian pose  *)*)
(*dp = p0Tdes - p0Tcurrent ;*)
(*Print["dp = ",MatrixForm[dp]] ;*)
(*dR = R0Tdes.Inverse[R0Tcurrent] ;*)
(*Print["dR = ",MatrixForm[dR]] ;*)
(*dpsi[[1,1]] = dR[[3,2]] ;*)
(*dpsi[[2,1]] = dR[[1,3]] ;*)
(*dpsi[[3,1]] = dR[[2,1]] ;*)
(*Print["dpsi = ",MatrixForm[dpsi]] ;*)
(*For[i=1, i<=3,i++,*)
(*{dx[[i,1]] = dp[[i,1]] ,*)
(*dx[[i+3,1]] = dpsi[[i,1]]}*)
(*] ;*)
(*Print["dx = ",MatrixForm[dx]] ;*)
(**)
(*(*  Calculate the norm of the Cartesian position and orientation errors  *)*)
(*dpnorm[iteration] = 0 ;*)
(*dpsinorm[iteration] = 0 ;*)
(*For[i=1, i<=3,i++,*)
(*{dpnorm[iteration] = dpnorm[iteration] + dp[[i,1]]* dp[[i,1]],*)
(*dpsinorm[iteration] = dpsinorm[iteration] + dpsi[[i,1]]*dpsi[[i,1]]}*)
(*] ;*)
(*dpnorm[iteration] = Sqrt[dpnorm[iteration]];*)
(*dpsinorm[iteration] = Sqrt[dpsinorm[iteration]];*)
(*Print["dpos error = ",dpnorm[iteration]] ;*)
(*Print["dpsi error = ",dpsinorm[iteration]] ;*)
(**)
(*(*  STEP 3:  Find the Jacobian for current joint angles*)
(*NOTE:  You have to change this next line if your variables include d[i]'s  *)*)
(*J0current = J0 //. {\[Theta][1]->q[[1,1]],\[Theta][2]->q[[2,1]],\[Theta][3]->q[[3,1]],\[Theta][4]->q[[4,1]],\[Theta][5]->q[[5,1]],\[Theta][6]->q[[6,1]]} ;*)
(*Print["J0current = ", MatrixForm[J0current]] ;*)
(**)
(*(*  STEP 4:  Find the approximate change in the joint angles to get to desired Cartesian pose:*)
(*use the robust pseudoinverse of J in case it is singular *)*)
(*Jinv=PseudoInverse[J0current] ;*)
(*dq = Jinv.dx ;*)
(**)
(*(*  STEP 5:  Update the joint angles  *)*)
(*q = q + dq ;*)
(*Print["q = ",MatrixForm[q]] ;*)
(**)
(*(*  STEP 6:  Calculate the norm of the joint angle change  *)*)
(*dqnorm[iteration] = 0 ;*)
(*For[i=1, i<=DOF,i++,*)
(*dqnorm[iteration] = dqnorm[iteration] + dq[[i,1]]*dq[[i,1]]*)
(*] ;*)
(*dqnorm[iteration] =Sqrt[dqnorm[iteration]];*)
(*Print["q error = ",dqnorm[iteration]] ;*)
(*}*)
(*];*)
(**)
